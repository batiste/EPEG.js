<html>
<head>
<style>
body, html {
  font-weight:16px;
  font-family: Helvetica neue, sans-serif;
}
textarea {
  width:100%;
  height:600px;
  font-size:14px;
}
div.col {
  float:left;
  width:30%;
  margin-right:3%;
}
h1, h2, h3 {
  margin: 0.4em 0;
}
#error {
  padding:0 1em;
  background: #fee;
  position:absolute;
  bottom:1;
  left:1;
  right:1;
  margin:0;
}
button {
  font-size:1.2em
}
</style>
</head>
<body>
<h1>
EPEG.js demo, implementation of a Python-like language
</h1>

<p>More info on the github page <a href="https://github.com/batiste/EPEG.js">https://github.com/batiste/EPEG.js</a></p>

<div style="clear:both">
<div class="col" style="position:relative">
  <h2>Input language</h2>
<textarea id="in">

g = "multiline
string"

def fib(n)
    if n < 2
        return n
    return fib(n-2) + fib(n-1)

array = [1, 2, 2 + 1]
object = {a: 1, toto: [1, 2]}

// function parameters can have default values
def test(a, b=1+1)
  a = 1
  // avoiding the error of CoffeScript: no implicit global
  g = 1
  // explicitly assign a value to a variable in a outer scope
  array := [1]
  return def(f) a + 10

for key, value in array
  if value == 1
    break
  else
    console.log(key, value)

array.map(def(i) fib(i * 3))

</textarea>

<pre id="error" style=""></pre>

</div>
<div class="col">
<h2>AST</h2>
<textarea id="out"></textarea>
</div>

<div class="col">
<h2>Output language</h2>
<textarea id="code"></textarea>
<button id="evalButton">Eval</button>
<pre id="evalResult"></pre>
</div>
</div>

<h2>Grammar definition</h2>

<pre id="grammarOut"></pre>

<h2>Tokens definition</h2>

<pre id="tokenOut"></pre>

<script src='parser.js'></script>
<script>

function spacer(n) {
  var out = "";
  for(var i=0; i<n; i++) {
    out += " ";
  }
  return out;
}


var levelStack = [0];
function currentLevel() {
  return levelStack[levelStack.length - 1];
}

function sp(mod) {
  if(mod !== undefined) {
    return spacer(2 * (levelStack.length + mod));
  }
  return spacer(2 * levelStack.length);
}


function indentType(l) {
  if(l > currentLevel()) {
    return 'indent';
  }
  if(l < currentLevel()) {
    return 'dedent';
  }
  return 'samedent';
}

function dent(dentType) {
  return function _dent(input) {
    var m = input.match(/^\n[ ]*/);
    if(m) {
    var indent = m[0].length - 1;
      if(indentType(indent) === dentType) {
        if(dentType == 'dedent') {
          levelStack.pop();
          return spacer();
        }
        if(dentType == 'indent') {
          levelStack.push(indent);
        }
        return m[0];
      }
    }
  };
}

// token are matched in order of declaration
// TODO: add functions
var tokenDef = {
  comment: commentDef,
  function_def: /^def/,
  ret: /^return/,
  _if: /^if/,
  _elseif: /^elseif/,
  _else: /^else/,
  r_arrow: /^\-\>/,
  for_loop: /^for/,
  _in: /^in/,
  name: /^[a-zA-Z_$][0-9a-zA-Z_]{0,29}/, // 30 chars max
  math_operators: /^(\+\+|\-\-)/,
  binary_operators: /^(\&\&|\|\||\&|\||<<|\>\>)/,
  comparison: /^(<=|>=|<|>|===|!=|==)/,
  assign: /^(\+=|-=|=|:=)/,
  number: /^[0-9]+\.?[0-9]*/, // only positive for now
  comma: /^\,/,
  dot: /^\./,
  colon: /^\:/,
  open_par: /^\(/,
  close_par: /^\)/,
  open_bra: /^\[/,
  close_bra: /^\]/,
  open_curly: /^\{/,
  close_curly: /^\}/,
  math: /^[-|\+|\*|/|%]/,
  samedent: dent('samedent'),
  dedent: dent('dedent'),
  indent: dent('indent'),
  //newline: /^(\r?\n|$)/,
  W: /^[ ]/,
  string: stringDef,
};

function stringDef(input) {
  if(input.charAt(0) === '"') {
    var i = 1;
    while(input.charAt(i)) {
      var ch = input.charAt(i);
      if(ch === '\\') {
        i++;
      } else if(ch === '"') {
        return input.slice(0, i+1);
      }
      i++;
    }
  }
}

function commentDef(input) {
  if(input.indexOf("//") === 0) {
    var i = 2;
    while(input.charAt(i)) {
      var ch = input.charAt(i);
      if(ch === '\n') {
        return input.slice(0, i);
      }
      i++;
    }
  }
}

function f_def(params) {
  return [params.fn, params.p, params.b];
}

function lambda_def(params) {
  return [params.fn, params.p, params.b];
}

function else_def(params) {
  return [params.b];
}

function else_if_def(params) {
  return [params.e, params.b];
}

function if_def(params) {
  return [params.e, params.b, params.elif, params.el];
}

function forLoop(params) {
  return [params.k, params.v, params.a, params.b];
}
forLoopCount = 1;

var grammarDef = {
  "START": {rules:["LINE* EOF"]},
  "LINE": {rules:["STATEMENT samedent*", "comment? samedent"]},
  "STATEMENT": {rules:["ASSIGN", "IF", "FOR", "EXPR", "RETURN"]},
  "VALUE": {rules:["number", "string"]},
  "BLOCK": {rules: ["indent LINE+ dedent"]},
  "FUNC_DEF_PARAMS": {rules:[
      "p1:FUNC_DEF_PARAMS comma W p2:FUNC_DEF_PARAMS",
      "p1:name assign e:EXPR",
      "p1:name",
    ],
  },
  "LAMBDA": {rules:[
      "function_def open_par p:FUNC_DEF_PARAMS? close_par W b:EXPR",
      "function_def W fn:name open_par p:FUNC_DEF_PARAMS? close_par W b:EXPR",
    ],
    hooks: [lambda_def, lambda_def]
  },
  "FUNC_DEF": {rules:[
      "function_def open_par p:FUNC_DEF_PARAMS? close_par b:BLOCK",
      "function_def W fn:name open_par p:FUNC_DEF_PARAMS? close_par b:BLOCK",
    ],
    hooks: [f_def, f_def]
  },
  "ELSE_IF": {rules:["samedent _elseif W e:EXPR b:BLOCK"], hooks:[else_if_def]},
  "ELSE": {rules:["samedent _else b:BLOCK"], hooks:[else_def]},
  "IF": {rules:["_if W e:EXPR b:BLOCK elif:ELSE_IF* el:ELSE?"], hooks:[if_def]},
  "MATH": {rules:["e1:EXPR W? op:math W? e2:EXPR"]},
  "PATH": {rules:["PATH dot name", "PATH open_bra number close_bra", "name"]},
  "ASSIGN": {rules:["left:EXPR W? op:assign W? right:EXPR"], hooks:[
    function(p){
      return {left:p.left, op:p.op, right:p.right};
    }]
  },
  "FUNC_CALL_PARAMS": {rules:["FUNC_CALL_PARAMS comma W? EXPR", "EXPR"]},
  "FUNC_CALL": {rules:["name open_par FUNC_CALL_PARAMS? close_par"]},

  "FOR": {rules:[
    "for_loop W k:name comma W v:name W _in W a:name b:BLOCK",
    "for_loop W v:name W _in W a:name b:BLOCK"],
    hooks: [forLoop, forLoop]
  },

  "COMMA_SEPARATED_EXPR": {rules:[
    "EXPR comma samedent? W COMMA_SEPARATED_EXPR",
    "EXPR"
  ]},

  "ARRAY": {rules:[
    "open_bra c:COMMA_SEPARATED_EXPR? close_bra",
  ]},

  "MEMBERS": {rules:[
    "name colon W EXPR comma W MEMBERS",
    "name colon W EXPR"
  ]},

  "OBJECT": {rules:[
    "open_curly MEMBERS? close_curly",
  ]},

  "RETURN": {rules:["ret W EXPR", "ret"]},
  "RIGHT_EXPR": {rules: [
    "math_operators",
    "W? binary_operators W? EXPR",
    "W? comparison W? EXPR",
    "dot EXPR",
    "open_bra EXPR close_bra"
  ]},
  "EXPR": {rules: [
    "MATH",
    "EXPR RIGHT_EXPR",
    "FUNC_CALL",
    "FUNC_DEF",
    "LAMBDA",
    "number",
    "open_par EXPR close_par",
    "string",
    "name",
    "PATH",
    "ARRAY",
    "OBJECT"]},
};

window.onload = function() {

var gram = EPEG.compileGrammar(grammarDef, tokenDef);

function dGet(id){ return document.getElementById(id); }
var din = dGet('in');
var dout = dGet('out');
var code = dGet('code');
var gOut = dGet('grammarOut');
gOut.textContent = JSON.stringify(grammarDef, false, 2);
var tOut = dGet('tokenOut');
tOut.textContent = JSON.stringify(tokenDef, false, 2);

dGet('evalButton').onclick = function() {
  var result = eval(code.value);
  dGet('evalResult').textContent = result;
};

din.onkeyup = function() {
  outit();
};

function outit() {
  namespaces = [{}];
  forLoopCount = 1;
  lastLevel = 0;
  try {
    var r = gram.parse(din.value);
    //console.log(EPEG.tokenize(din.value, gram.tokenDef));
    lastLevel = 0;
    if(!r.complete) {
      throw r.hint;
    }
    code.value = generateCode(r);
    dout.value = JSON.stringify(r, false, 2);
    document.getElementById("error").textContent = "";
  } catch(e) {
    document.getElementById("error").textContent = String(e);
    throw e;
  }
}

var namespaces = [{}];

function generateParams(ps, ns) {
  var str = '';
  if(ps){
    var params = ps.children;
    if(params) {
      params.map(function(p) {
        if(p.type == 'name') {
          ns[p.value] = true;
        }
        if(p.children) {
          str += generateParams(p, ns);
        } else {
          str += p.value;
        }
      });
    }
  }
  return str;
}

var backend = {
  'FUNC_DEF': function(node) {
    var name = "";
    namespaces.push({});
    var ns = namespaces[namespaces.length -1];
    if(node.children[0]) {
      name = node.children[0].value;
    }
    str = "function " + name + "(";
    if(node.children[1]) {
      str += generateCode(node.children[1]);
    }
    str += ') {';
    for(var key in ns) {
      if(ns[key] !== true && ns[key] != undefined) {
        str += '\n'+sp()+'if('+key+' === undefined) {'+key+'='+generateCode(ns[key])+'};';
      }
    }
    if(node.children[2]) {
      str += generateCode(node.children[2]);
    }
    namespaces.pop();
    return str + '\n'+sp()+'}';
  },
  'FUNC_DEF_PARAMS': function(node) {
    var str = "", i;
    var ns = namespaces[namespaces.length -1];
    if(node.children[0].type === 'name') {
      ns[node.children[0].value] = true;
      if(node.children[1] && node.children[1].type === 'assign') {
        ns[node.children[0].value] = node.children[2];
      }
    }
    for(i=0;i<node.children.length; i++) {
      var n = node.children[i];
      if(n.type === 'name' || n.type === 'FUNC_DEF_PARAMS' || n.type === 'comma' || n.type === 'window') {
        str += generateCode(node.children[i]);
      }
    }
    return str;
  },
  'LAMBDA': function(node) {
    var name = "";
    namespaces.push({});
    var ns = namespaces[namespaces.length -1];
    if(node.children[0]) {
      name = node.children[0].value;
    }
    str = "function " + name + "(";
    if(node.children[1]) {
      str += generateCode(node.children[1], ns);
    }
    str += ') { return ';
    if(node.children[2]) {
      str += generateCode(node.children[2], ns);
    }
    namespaces.pop();
    return str + "; }";
  },
  'ASSIGN': function(node) {
    var prefix = "";
    var op = node.children.op.value;
    var ns = namespaces[namespaces.length -1];
    if(node.children.left.children[0].type === 'name') {
      var ch = node.children.left.children[0];
      if(ns[ch.value] === undefined) {
        if(op == ':=') {
          op = '=';
        } else {
          prefix = 'var ';
        }
        ns[ch.value] = true;
      }
    }
    return prefix+generateCode(node.children.left) + op + generateCode(node.children.right);
  },
  'STATEMENT': function(node) {
    return generateCode(node.children[0]) + ';';
  },
  'IF': function(node) {
    var str = '';
    str = 'if('+generateCode(node.children[0]) + '){' + generateCode(node.children[1]) + '\n'+sp()+'}';
    if(node.children[2]) {
      if(Array.isArray(node.children[2])) {
        for (var i = 0; i < node.children[2].length; i++) {
          str += generateCode(node.children[2][i]);
        }
      } else {
        str += generateCode(node.children[2]);
      }
    }
    if(node.children[3]) {
      str += generateCode(node.children[3]);
    }
    return str;
  },
  'FOR': function(node) {
    var keyName = "_index"+forLoopCount;
    forLoopCount++;
    if(node.children[0]) {
      keyName = node.children[0].value;
    }
    var str = 'for(var '+keyName+' in '+node.children[2].value+'.keys()) {\n';
    str += sp() + 'var ' + node.children[1].value + '=' + node.children[2].value + '[' + keyName + '];';
    str += generateCode(node.children[3]) +'\n}';
    return str;
  },
  'ELSE_IF': function(node) {
    return 'else if('+generateCode(node.children[0])+') {'+generateCode(node.children[1])+'\n'+sp()+'}';
  },
  'ELSE': function(node) {
    return 'else {'+generateCode(node.children[0])+'\n'+sp()+'}';
  },
  'string': function(node) {
    return node.value.replace(/\n/g, "\\\n");
  },
};

function generateCode(node, ns) {
  if(!node) {
    //debugger
  }
  if(backend[node.type]) {
    return backend[node.type](node);
  }
  if(node.value !== undefined) {
    return node.value;
  }
  var str = "", i;
  if(!node.children) {
    return '';
  }
  for(i=0;i<node.children.length; i++) {
    str += generateCode(node.children[i], ns);
  }
  return str;
}

outit();

};

</script>