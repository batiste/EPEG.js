<html>
<head>
<style>
body, html {
  font-weight:16px;
  font-family: Helvetica neue, sans-serif;
}
textarea {
  width:100%;
  height:400px;
  font-size:14px;
}
div.col {
  float:left;
  width:30%;
  margin-right:3%;
}
h1, h2, h3 {
  margin: 0.4em 0;
}
#error {
  padding:0 1em;
  background: #fee;
  position:absolute;
  bottom:1;
  left:1;
  right:1;
  margin:0;
}
</style>
</head>
<body>
<h1>
EPEG.js demo
</h1>

<a href="https://github.com/batiste/EPEG.js">https://github.com/batiste/EPEG.js</a>

<div style="clear:both">
<div class="col" style="position:relative">
  <h2>Input language</h2>
<textarea id="in">

d = 10
e = 11

def test(a, b)
  a = 1
  h = 1
  d = 10
  e := 11
  return def test2(toto)
    a = 2
    d := 10
    toto = 2
    return def(f) a + 10




</textarea>

<pre id="error" style=""></pre>

</div>
<div class="col">
<h2>AST</h2>
<textarea id="out"></textarea>
</div>

<div class="col">
<h2>Output language</h2>
<textarea id="code"></textarea>
</div>
</div>

<h2>Grammar definition</h2>

<pre id="grammarOut"></pre>

<h2>Tokens definition</h2>

<pre id="tokenOut"></pre>

<script src='parser.js'></script>
<script>

function spacer(n) {
  var out = "";
  for(var i=0; i<n; i++) {
    out += " ";
  }
  return out;
}


var levelStack = [0];
function currentLevel() {
  return levelStack[levelStack.length - 1];
}

function indentType(l) {
  if(l > currentLevel()) {
    return 'indent';
  }
  if(l < currentLevel()) {
    return 'dedent';
  }
  return 'samedent';
}

function dent(dentType) {
  return function _dent(input) {
    var m = input.match(/^\n[ ]*/);
    if(m) {
    var indent = m[0].length - 1;
      if(indentType(indent) === dentType) {
        if(dentType == 'dedent') {
          levelStack.pop();
          return spacer();
        }
        if(dentType == 'indent') {
          levelStack.push(indent);
        }
        return m[0];
      }
    }
  };
}

// token are matched in order of declaration
// TODO: add functions
var tokenDef = {
  function_def: /^def/,
  ret: /^return/,
  _if: /^if/,
  _elseif: /^elseif/,
  _else: /^else/,
  r_arrow: /^\-\>/,
  name: /^[a-zA-Z_$][0-9a-zA-Z_]{0,29}/, // 30 chars max
  math_operators: /^(\+\+|\-\-)/,
  binary_operators: /^(\&\&|\|\||\&|\||\<\<|\>\>)/,
  comparison: /^(<=|>=|<|>|===|!=|==)/,
  assign: /^(\+=|-=|=|:=)/,
  number: /^-?[0-9]+\.?[0-9]*/,
  comma: /^\,/,
  dot: /^\./,
  for_loop: /^for/,
  open_par: /^\(/,
  close_par: /^\)/,
  open_bra: /^\[/,
  close_bra: /^\]/,
  math: /^[-|\+|\*|/|%]/,
  samedent: dent('samedent'),
  dedent: dent('dedent'),
  indent: dent('indent'),
  //newline: /^(\r?\n|$)/,
  W: /^[ ]/,
  string: /^"([^"\\]*(\\.[^"\\]*)*)"/,
};

function f_def(params) {
  return [params.fn, params.p, params.b];
}

function lambda_def(params) {
  return [params.fn, params.p, params.b];
}

function else_def(params) {
  return [params.b];
}

function else_if_def(params) {
  return [params.e, params.b];
}

function if_def(params) {
  return [params.e, params.b, params.elif, params.el];
}

function flattenLeftRecursion(node, accu) {
  if(node.children === undefined) {
    accu.push(node);
  } else {
    for(var i=0; i<node.children.length; i++) {
      flattenLeftRecursion(node.children[i], accu);
    }
  }
}

function unrollParams(params) {
  var p = [];
  flattenLeftRecursion(params.p1, p);
  p.push(params.p2);
  return p;
}

var grammarDef = {
  "START": {rules:["LINE* EOF"]},
  "LINE": {rules:["STATEMENT samedent*", "samedent"]},
  "STATEMENT": {rules:["ASSIGN", "EXPR", "RETURN", "IF"]},
  "VALUE": {rules:["number", "string"]},
  "BLOCK": {rules: ["indent LINE+ dedent"]},
  "FUNC_DEF_PARAMS": {rules:["p1:FUNC_DEF_PARAMS comma W p2:name", "p1:name"], hooks: [unrollParams, false]},
  "LAMBDA": {rules:[
      "function_def open_par p:FUNC_DEF_PARAMS? close_par W b:EXPR",
      "function_def W fn:name open_par p:FUNC_DEF_PARAMS? close_par W b:EXPR",
    ],
    hooks: [lambda_def, lambda_def]
  },
  "FUNC_DEF": {rules:[
      "function_def open_par p:FUNC_DEF_PARAMS? close_par b:BLOCK",
      "function_def W fn:name open_par p:FUNC_DEF_PARAMS? close_par b:BLOCK",
    ],
    hooks: [f_def, f_def]
  },
  "ELSE_IF": {rules:["samedent _elseif W e:EXPR b:BLOCK"], hooks:[else_if_def]},
  "ELSE": {rules:["samedent _else b:BLOCK"], hooks:[else_def]},
  "IF": {rules:["_if W e:EXPR b:BLOCK elif:ELSE_IF* el:ELSE?"], hooks:[if_def]},
  "MATH": {rules:["e1:EXPR W? op:math W? e2:EXPR"]},
  "PATH": {rules:["PATH dot name", "PATH open_bra number close_bra", "name"]},
  "ASSIGN": {rules:["left:EXPR W? op:assign W? right:EXPR"], hooks:[function(p){return p;}]},
  "FUNC_CALL_PARAMS": {rules:["FUNC_CALL_PARAMS comma W? EXPR", "EXPR"]},
  "FUNC_CALL": {rules:["name open_par FUNC_CALL_PARAMS? close_par"]},
  "RETURN": {rules:["ret W EXPR", "ret"]},
  "RIGHT_EXPR": {rules: [
    "math_operators",
    "W binary_operators W EXPR",
    "W comparison W EXPR",
    "dot EXPR",
    "open_bra EXPR close_bra"
  ]},
  "EXPR": {rules: [
    "MATH",
    "EXPR RIGHT_EXPR",
    "FUNC_CALL",
    "FUNC_DEF",
    "LAMBDA",
    "number",
    "open_par EXPR close_par",
    "string",
    "name",
    "PATH"]},
};

window.onload = function() {

var gram = EPEG.compileGrammar(grammarDef, tokenDef);

function assertComplete(input, g) {
  lastLevel = 0;
  var r = g.parse(input);
  if(!r.complete) {
    lastLevel = 0;
    var ts = EPEG.tokenize(input, g.tokenDef);
    lastLevel = 0;
    console.log("Incomplete parsing on: " + input + ", leftover ", r, ts, ts.slice(r.consumed).map(function(i){return i.value;}));
  }
}


var din = document.getElementById('in');
var dout = document.getElementById('out');
var code = document.getElementById('code');
var gOut = document.getElementById('grammarOut');
gOut.textContent = JSON.stringify(grammarDef, false, 2);
var tOut = document.getElementById('tokenOut');
tOut.textContent = JSON.stringify(tokenDef, false, 2);

din.onkeyup = function() {
  outit();
};

function outit() {
  namespaces = [{}];
  lastLevel = 0;
  try {
    var r = gram.parse(din.value);
    //console.log(EPEG.tokenize(din.value, gram.tokenDef));
    lastLevel = 0;
    if(!r.complete) {
      throw r.hint;
    }
    code.value = generateCode(r);
    dout.value = JSON.stringify(r, false, 2);
    document.getElementById("error").textContent = "";
  } catch(e) {
    document.getElementById("error").textContent = String(e);
    throw e;
  }
}

var namespaces = [{}];

function generateParams(ps, ns) {
  var str = '';
  if(ps){
    var params = ps.children;
    if(params) {
      params.map(function(p){
        ns[p.value] = true;
        str += p.value;
        if(params[params.length - 1] !== p) {
          str += ', ';
        }
      });
    }
  }
  return str;
}

var backend = {
  'FUNC_DEF': function(node) {
    var name = "";
    namespaces.push({});
    var ns = namespaces[namespaces.length -1];
    if(node.children[0]) {
      name = node.children[0].value;
    }
    str = "function " + name + "(";
    str += generateParams(node.children[1], ns);
    str += ') {';
    if(node.children[2]) {
      str += generateCode(node.children[2]);
    }
    namespaces.pop();
    return str + "\n}";
  },
  'LAMBDA': function(node) {
    var name = "";
    namespaces.push({});
    var ns = namespaces[namespaces.length -1];
    if(node.children[0]) {
      name = node.children[0].value;
    }
    str = "function " + name + "(";
    str += generateParams(node.children[1], ns);
    str += ') { return ';
    if(node.children[2]) {
      str += generateCode(node.children[2]);
    }
    namespaces.pop();
    return str + "; }";
  },
  'ASSIGN': function(node) {
    var prefix = "";
    var op = node.children.op.value;
    var ns = namespaces[namespaces.length -1];
    if(node.children.left.children[0].type === 'name') {
      var ch = node.children.left.children[0];
      if(ns[ch.value] === undefined) {
        if(op == ':=') {
          op = '=';
        } else {
          prefix = 'var ';
        }
        ns[ch.value] = true;
      }
    }
    return prefix+generateCode(node.children.left) + op + generateCode(node.children.right);
  },
  'STATEMENT': function(node) {
    return generateCode(node.children[0]) + ';';
  },
  'IF': function(node) {
    var str = '';
    str = 'if('+generateCode(node.children[0]) + '){' + generateCode(node.children[1]) + '\n}';
    if(node.children[2]) {
      if(Array.isArray(node.children[2])) {
        for (var i = 0; i < node.children[2].length; i++) {
          str += generateCode(node.children[2][i]);
        }
      } else {
        str += generateCode(node.children[2]);
      }
    }
    if(node.children[3]) {
      str += generateCode(node.children[3]);
    }
    return str;
  },
  'ELSE_IF': function(node) {
    return 'else if('+generateCode(node.children[0])+') {'+generateCode(node.children[1])+'\n}';
  },
  'ELSE': function(node) {
    return 'else {'+generateCode(node.children[0])+'\n}';
  },
};

function generateCode(node) {
  if(!node) {
    //debugger
  }
  if(node.value !== undefined) {
    return node.value;
  }
  var str = "", i;
  if(backend[node.type]) {
    return backend[node.type](node);
  }
  if(!node.children) {
    return '';
  }
  for(i=0;i<node.children.length; i++) {
    str += generateCode(node.children[i]);
  }
  return str;
}

outit();

};

</script>