<html>
<head>
<style>
body, html {
  font-weight:16px;
  font-family: Helvetica neue, sans-serif;
}
textarea {
  width:95%;
  height:600px;
  font-size:14px;
}
div.col {
  float:left;
  width:33%;
}
h1, h2, h3 {
  margin: 0.4em 0;
}
</style>
</head>
<body>
<h1>
EPEG.js demo
</h1>

<a href="https://github.com/batiste/EPEG.js">https://github.com/batiste/EPEG.js</a>

<div style="clear:both">
<div class="col">
  <h2>Input language</h2>
<textarea id="in">
a = 1
a = 2
b = 2

def myFunc(p1, p2)
  a = 3
  b := 2
  b = 5
  return def(a) return a + 1

if 1 == 1
  1
else
  2

</textarea>
</div>
<div class="col">
<h2>AST</h2>
<textarea id="out"></textarea>
</div>

<div class="col">
<h2>Output language</h2>
<textarea id="code"></textarea>
</div>
</div>

<h2>Grammar definition</h2>

<pre id="grammarOut"></pre>

<h2>Tokens definition</h2>

<pre id="tokenOut"></pre>

<script src='parser.js'></script>
<script>


var lastLevel = 0;
function indentType(l) {
  if(l > lastLevel) {
    return 'indent';
  }
  if(l < lastLevel) {
    return 'dedent';
  }
  return 'samedent';
}

function dent(dentType) {
  return function _dent(input) {
    var m = input.match(/^\n[ ]*/);
    if(m && indentType(m[0].length - 1) === dentType) {
      lastLevel = m[0].length - 1;
      //if(dentType == 'dedent') {
      //  return '';
      //}
      return m[0];
    }
  };
}


// token are matched in order of declaration
// TODO: add functions
var tokenDef = {
  function_def: /^def/,
  ret: /^return/,
  _if: /^if/,
  _else: /^else/,
  _elseif: /^elseif/,
  r_arrow: /^\-\>/,
  name: /^[a-zA-Z_$][0-9a-zA-Z_]{0,29}/, // 30 chars max
  math_operators: /^(\+\+|\-\-)/,
  binary_operators: /^(\&\&|\|\||\&|\||\<\<|\>\>)/,
  comparison: /^(<=|>=|<|>|===|!=|==)/,
  assign: /^(\+=|-=|=|:=)/,
  number: /^-?[0-9]+\.?[0-9]*/,
  comma: /^\,/,
  dot: /^\./,
  for_loop: /^for/,
  open_par: /^\(/,
  close_par: /^\)/,
  open_bra: /^\[/,
  close_bra: /^\]/,
  math: /^[-|\+|\*|/|%]/,
  samedent: dent('samedent'),
  dedent: dent('dedent'),
  indent: dent('indent'),
  newline: /^(\r?\n|$)/,
  W: /^[ ]/,
  string: /^"([^"\\]*(\\.[^"\\]*)*)"/,
};

function f_def(params) {
  return [params.fn, params.p, params.b];
}

function if_def(params) {
  return params;
}

var grammarDef = {
  "START": {rules:["LINE* EOF"]},
  "LINE": {rules:["STATEMENT samedent", "samedent", "BLOCK_STATEMENT"]},
  "BLOCK_STATEMENT": {rules:["IF_DEF", "FUNC_DEF"]},
  "STATEMENT": {rules:["ASSIGN", "EXPR"]},
  "VALUE": {rules:["number", "string"]},
  "BLOCK_END": {rules:["STATEMENT dedent", "BLOCK_STATEMENT dedent"]},
  "BLOCK": {rules: ["indent LINE* BLOCK_END"]},
  "FUNC_DEF_PARAMS": {rules:["FUNC_DEF_PARAMS comma W name", "name"]},
  "FUNC_DEF": {rules:[
      "function_def open_par p:FUNC_DEF_PARAMS? close_par W b:EXPR",
      "function_def open_par p:FUNC_DEF_PARAMS? close_par b:BLOCK?",
      "function_def W fn:name open_par p:FUNC_DEF_PARAMS? close_par b:BLOCK?",
    ],
    hooks: [f_def, f_def, f_def]
  },
  "ELSE_DEF": {rules:["_else BLOCK"], hooks:[if_def]},
  "IF_DEF": {rules:["_if W e:EXPR b:BLOCK el:ELSE_DEF?"], hooks:[if_def]},
  "MATH": {rules:["e1:EXPR W? op:math W? e2:EXPR"]},
  "PATH": {rules:["PATH dot name", "PATH open_bra number close_bra", "name"]},
  "ASSIGN": {rules:["left:EXPR W? op:assign W? right:EXPR"], hooks:[function(p){return p;}]},
  "FUNC_CALL_PARAMS": {rules:["FUNC_CALL_PARAMS comma W? EXPR", "EXPR"]},
  "FUNC_CALL": {rules:["name open_par FUNC_CALL_PARAMS? close_par"]},
  "RETURN": {rules:["ret W EXPR", "ret"]},
  "LEFTY": {rules: [
    "math_operators",
    "W binary_operators W EXPR",
    "W comparison W EXPR",
    "dot EXPR",
    "open_bra EXPR close_bra"
  ]},
  "EXPR": {rules: [
    "MATH",
    "EXPR LEFTY",
    "FUNC_CALL",
    "FUNC_DEF",
    "RETURN",
    "number",
    "open_par EXPR close_par",
    "string",
    "name",
    "PATH"]},
};

window.onload = function() {

var gram = EPEG.compileGrammar(grammarDef, tokenDef);

function assertComplete(input, g) {
  lastLevel = 0;
  var r = g.parse(input);
  if(!r.complete) {
    lastLevel = 0;
    var ts = EPEG.tokenize(input, g.tokenDef);
    lastLevel = 0;
    console.log("Incomplete parsing on: " + input + ", leftover ", r, ts, ts.slice(r.consumed).map(function(i){return i.value;}));
  }
}

/*
assertComplete("1 + 1 + 3 - 8 / 3 * 2", gram);
assertComplete("hello = 1", gram);
assertComplete("1 == 1", gram);
assertComplete("hello != toto", gram);
assertComplete("def test()", gram);
assertComplete("def test(a, b)", gram);
assertComplete("def(a, b)", gram);
assertComplete("test(a + 1, 2 + b) - 2", gram);
assertComplete('"hello workd" + 1', gram);

assertComplete("def test()\n  1\n", gram);
assertComplete('(1)', gram);
assertComplete('(1 + 1)', gram);*/

var din = document.getElementById('in');
var dout = document.getElementById('out');
var code = document.getElementById('code');
var gOut = document.getElementById('grammarOut');
gOut.textContent = JSON.stringify(grammarDef, false, 2);
var tOut = document.getElementById('tokenOut');
tOut.textContent = JSON.stringify(tokenDef, false, 2);

din.onkeyup = function() {
  outit();
};

function outit() {
  namespaces = [{}];
  lastLevel = 0;
  var r = gram.parse(din.value);
  console.log(EPEG.tokenize(din.value, gram.tokenDef));
  lastLevel = 0;
  code.value = generateCode(r);
  dout.value = JSON.stringify(r, false, 2);
}

var namespaces = [{}];

var backend = {
  'FUNC_DEF': function(node) {
    var name = "";
    namespaces.push({});
    if(node.children[0]) {
      name = node.children[0].value;
    }
    str = "function " + name + "(";
    if(node.children[1]) {
      str += generateCode(node.children[1]);
    }
    str += ') {';
    if(node.children[2]) {
      str += generateCode(node.children[2]);
    }
    namespaces.pop();
    return str + "}\n";
  },
  'ASSIGN': function(node) {
    var prefix = "";
    var op = node.children.op.value;
    var ns = namespaces[namespaces.length -1];
    if(node.children.left.children[0].type === 'name') {
      var ch = node.children.left.children[0];
      if(ns[ch.value] === undefined) {
        if(op == ':=') {
          op = '=';
        } else {
          prefix = 'var ';
        }
        ns[ch.value] = true;
      }
    }
    return prefix+generateCode(node.children.left) + op + generateCode(node.children.right) + ';';
  },
  'IF_DEF': function(node) {
    var str = '';
    str = 'if('+generateCode(node.children.e) + '){' + generateCode(node.children.b) + '}';
    if(node.children.el) {
      str += ' else {'+generateCode(node.children.el.children.$1)+'}';
    }
    return str;
  }
};

function generateCode(node) {
  if(!node) {
  }
  if(node.value !== undefined) {
    return node.value;
  }
  var str = "", i;
  if(backend[node.type]) {
    return backend[node.type](node);
  }
  if(!node.children) {
    return '';
  }
  for(i=0;i<node.children.length; i++) {
    str += generateCode(node.children[i]);
  }
  return str;
}

outit();

};

</script>